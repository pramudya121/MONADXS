<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>PRAMZX DeFi - Monad Testnet</title>
<style>
  /* Reset and base */
  *, *::before, *::after {
    box-sizing: border-box;
  }
  
  body {
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: url('https://images.unsplash.com/photo-1506744038136-46273834b3fb?auto=format&fit=crop&w=3000&q=80') no-repeat center center fixed;
    background-size: cover;
    color: #eee;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    align-items: center;
    overflow: hidden;
  }

  #app {
    background: rgba(0, 0, 0, 0.7);
    border-radius: 12px;
    width: 100%;
    max-width: 1000px;
    max-height: 90vh;
    margin-top: 1rem;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem 1.5rem;
    border-bottom: 1px solid #444;
  }
  header h1 {
    margin: 0;
    font-weight: 700;
    font-size: 1.6rem;
    color: #00ff99;
    user-select: none;
  }
  #wallet-status {
    display: flex;
    align-items: center;
    gap: 0.6rem;
  }
  #wallet-address {
    font-family: monospace;
    font-size: 0.9rem;
    color: #00ffa3;
    user-select: text;
  }
  button#connectWallet {
    background-color: #00b377;
    border: none;
    color: #000;
    font-weight: 700;
    padding: 0.4rem 0.75rem;
    border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.2s ease;
  }
  button#connectWallet:hover {
    background-color: #00ffaa;
  }

  nav {
    background: #111a1a;
    display: flex;
    justify-content: center;
    border-bottom: 1px solid #333;
    user-select: none;
  }
  nav button {
    flex: 1;
    background: transparent;
    border: none;
    color: #ccc;
    padding: 0.9rem 0.6rem;
    cursor: pointer;
    font-weight: 600;
    transition: background-color 0.3s;
  }
  nav button.active, nav button:hover {
    background: #00b377;
    color: #070a05;
  }

  main {
    padding: 1rem 1.5rem;
    overflow-y: auto;
    flex-grow: 1;
    color: #ddd;
  }

  /* Forms and inputs */
  form {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    max-width: 450px;
    margin: auto;
  }
  label {
    font-weight: 600;
  }
  select, input[type="number"], input[type="text"] {
    background: #222;
    border: 1px solid #444;
    color: #eee;
    padding: 0.5rem 0.8rem;
    border-radius: 6px;
    font-size: 1rem;
    width: 100%;
  }
  input[type="number"]::-webkit-inner-spin-button,
  input[type="number"]::-webkit-outer-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
  input[type="number"] {
    -moz-appearance:textfield;
  }
  button.actionBtn {
    background-color: #00b377;
    border: none;
    color: #000;
    font-weight: 700;
    padding: 0.6rem;
    border-radius: 6px;
    cursor: pointer;
    font-size: 1.1rem;
    transition: background-color 0.3s ease;
    user-select: none;
  }
  button.actionBtn:disabled {
    background-color: #444;
    cursor: not-allowed;
  }
  button.actionBtn:hover:not(:disabled) {
    background-color: #00ffbb;
  }

  /* Message area */
  #message {
    background: #006633;
    border-radius: 8px;
    padding: 0.8rem 1rem;
    margin-bottom: 1rem;
    font-weight: 600;
    color: #ceffce;
    text-align: center;
  }

  /* Token balances */
  #balances {
    max-width: 450px;
    background: rgba(0,0,0,0.3);
    border-radius: 10px;
    margin: 1rem auto;
    padding: 0.8rem 1rem;
  }
  #balances h3 {
    margin-top: 0;
    margin-bottom: 0.4rem;
    color: #00ff99;
  }
  #balances ul {
    list-style: none;
    padding-left: 0;
    margin: 0;
  }
  #balances ul li {
    padding: 0.3rem 0;
    font-family: monospace;
    color: #aaffaa;
  }

  /* Confirmation modal */
  #confirmOverlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.75);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  #confirmBox {
    background: #001f00;
    border-radius: 12px;
    padding: 1.5rem;
    width: 90%;
    max-width: 400px;
    color: #aaffaa;
  }
  #confirmBox p {
    margin: 0 0 1.2rem 0;
    font-size: 1.1rem;
  }
  #confirmButtons {
    display: flex;
    justify-content: flex-end;
    gap: 1rem;
  }
  #confirmButtons button {
    padding: 0.6rem 1rem;
    font-size: 1rem;
    font-weight: 700;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    user-select: none;
  }
  #confirmButtons button.confirmBtn {
    background: #00bb00;
    color: #001900;
  }
  #confirmButtons button.cancelBtn {
    background: #bb0000;
    color: #190000;
  }
  #confirmButtons button.confirmBtn:hover {
    background: #00ff33;
  }
  #confirmButtons button.cancelBtn:hover {
    background: #ff3333;
  }

  /* Responsive */
  @media (max-width: 600px) {
    #app {
      max-width: 100vw;
      max-height: 100vh;
      border-radius: 0;
      margin-top: 0;
    }
    main form {
      padding: 0 1rem;
      max-width: 100%;
    }
    nav button {
      font-size: 0.85rem;
      padding: 0.7rem 0.3rem;
    }
  }
</style>
</head>
<body>
<div id="app" role="main" aria-label="PRAMZX DeFi Monad Testnet application">
  <header>
    <h1>PRAMZX DeFi - Monad Testnet</h1>
    <div id="wallet-status">
      <span id="wallet-address" aria-live="polite" aria-atomic="true">Not Connected</span>
      <button id="connectWallet" aria-label="Connect Wallet">Connect Wallet</button>
    </div>
  </header>
  <nav role="navigation" aria-label="Main navigation">
    <button class="active" data-tab="swap" aria-selected="true" role="tab" id="tab-swap">Swap</button>
    <button data-tab="liquidity" aria-selected="false" role="tab" id="tab-liquidity">Liquidity</button>
    <button data-tab="stake" aria-selected="false" role="tab" id="tab-stake">Stake</button>
    <button data-tab="unstake" aria-selected="false" role="tab" id="tab-unstake">Unstake</button>
    <button data-tab="deploy" aria-selected="false" role="tab" id="tab-deploy">Deploy</button>
    <button data-tab="nft" aria-selected="false" role="tab" id="tab-nft">Create NFT</button>
    <button data-tab="crosschain" aria-selected="false" role="tab" id="tab-crosschain">Crosschain</button>
  </nav>
  <main role="tabpanel">
    <section id="swap" class="tab-content" hidden>
      <h2>Swap Tokens</h2>
      <form id="swapForm" aria-label="Swap tokens form">
        <label for="swap-from">From Token:</label>
        <select id="swap-from" required aria-required="true"></select>
        <label for="swap-to">To Token:</label>
        <select id="swap-to" required aria-required="true"></select>
        <label for="swap-amount">Amount:</label>
        <input type="number" id="swap-amount" min="0.0001" step="any" required aria-required="true" />
        <button type="submit" class="actionBtn" disabled>Swap</button>
      </form>
    </section>
    <section id="liquidity" class="tab-content" hidden>
      <h2>Liquidity Pool</h2>
      <form id="liquidityForm" aria-label="Add liquidity form">
        <label for="liquidity-token1">Token 1:</label>
        <select id="liquidity-token1" required aria-required="true"></select>
        <label for="liquidity-amount1">Amount Token 1:</label>
        <input type="number" id="liquidity-amount1" min="0.0001" step="any" required aria-required="true" />
        <label for="liquidity-token2">Token 2:</label>
        <select id="liquidity-token2" required aria-required="true"></select>
        <label for="liquidity-amount2">Amount Token 2:</label>
        <input type="number" id="liquidity-amount2" min="0.0001" step="any" required aria-required="true" />
        <button type="submit" class="actionBtn" disabled>Add Liquidity</button>
      </form>
    </section>
    <section id="stake" class="tab-content" hidden>
      <h2>Stake Tokens</h2>
      <form id="stakeForm" aria-label="Stake tokens form">
        <label for="stake-token">Token:</label>
        <select id="stake-token" required aria-required="true"></select>
        <label for="stake-amount">Amount:</label>
        <input type="number" id="stake-amount" min="0.0001" step="any" required aria-required="true" />
        <button type="submit" class="actionBtn" disabled>Stake</button>
      </form>
    </section>
    <section id="unstake" class="tab-content" hidden>
      <h2>Unstake Tokens</h2>
      <form id="unstakeForm" aria-label="Unstake tokens form">
        <label for="unstake-token">Token:</label>
        <select id="unstake-token" required aria-required="true"></select>
        <label for="unstake-amount">Amount:</label>
        <input type="number" id="unstake-amount" min="0.0001" step="any" required aria-required="true" />
        <button type="submit" class="actionBtn" disabled>Unstake</button>
      </form>
    </section>
    <section id="deploy" class="tab-content" hidden>
      <h2>Deploy Smart Contract</h2>
      <form id="deployForm" aria-label="Deploy smart contract form">
        <label for="deploy-name">Token Name:</label>
        <input type="text" id="deploy-name" required aria-required="true" placeholder="My Token" />
        <label for="deploy-symbol">Token Symbol:</label>
        <input type="text" id="deploy-symbol" required aria-required="true" placeholder="MTK" />
        <label for="deploy-supply">Initial Supply:</label>
        <input type="number" id="deploy-supply" min="1" step="1" required aria-required="true" placeholder="1000000" />
        <button type="submit" class="actionBtn" disabled>Deploy ERC20 Token</button>
      </form>
    </section>
    <section id="nft" class="tab-content" hidden>
      <h2>Create NFT</h2>
      <form id="nftForm" aria-label="Create NFT form">
        <label for="nft-name">NFT Name:</label>
        <input type="text" id="nft-name" required aria-required="true" placeholder="My NFT" />
        <label for="nft-description">Description:</label>
        <input type="text" id="nft-description" required aria-required="true" placeholder="Describe your NFT" />
        <label for="nft-uri">Metadata URI (Image/JSON URL):</label>
        <input type="text" id="nft-uri" required aria-required="true" placeholder="https://..." />
        <button type="submit" class="actionBtn" disabled>Create NFT</button>
      </form>
    </section>
    <section id="crosschain" class="tab-content" hidden>
      <h2>Crosschain EVM Testnet</h2>
      <form id="crosschainForm" aria-label="Crosschain transaction form">
        <label for="crosschain-network">Select Network:</label>
        <select id="crosschain-network" aria-required="true">
          <option value="monad_testnet" selected>Monad Testnet</option>
          <option value="rinkeby">Rinkeby Testnet (Ethereum)</option>
          <option value="bsc_testnet">BSC Testnet</option>
          <option value="polygon_testnet">Polygon Testnet</option>
          <!-- add more testnets -->
        </select>
        <label for="crosschain-action">Select Action:</label>
        <select id="crosschain-action" aria-required="true">
          <option value="swap">Swap</option>
          <option value="stake">Stake</option>
          <option value="unstake">Unstake</option>
          <option value="liquidity">Add Liquidity</option>
          <option value="deploy">Deploy Token</option>
          <option value="createNFT">Create NFT</option>
        </select>
        <button type="button" class="actionBtn" id="crosschain-go">Go</button>
      </form>
      <p style="margin-top:1rem; font-size:0.9rem; color:#ccc;">Select a network and action to perform crosschain testnet transactions. Wallet will attempt to switch network if supported.</p>
    </section>
    <section id="balances" aria-live="polite" aria-atomic="true">
      <h3>Your Token Balances</h3>
      <ul id="balanceList">
        <!-- Balances will load here -->
      </ul>
    </section>
    <div id="message" role="alert" aria-live="assertive" style="display:none;"></div>
  </main>
</div>

<div id="confirmOverlay" role="dialog" aria-modal="true" aria-labelledby="confirmTitle" aria-describedby="confirmText">
  <div id="confirmBox">
    <p id="confirmText"></p>
    <div id="confirmButtons">
      <button class="confirmBtn" aria-label="Confirm transaction">Confirm</button>
      <button class="cancelBtn" aria-label="Cancel transaction">Cancel</button>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.min.js" integrity="sha256-Y2hwNDuGhxo9iIPiB9ggQWFWkZqX77FHYU0Wl83Z6o4=" crossorigin="anonymous"></script>
<script>
  (() => {
    const tokens = [
      {symbol:'MON', address:'0x0000000000000000000000000000000000000001', decimals:18},
      {symbol:'WMON', address:'0x0000000000000000000000000000000000000002', decimals:18},
      {symbol:'GMON', address:'0x0000000000000000000000000000000000000003', decimals:18},
      {symbol:'SHMON', address:'0x0000000000000000000000000000000000000004', decimals:18},
      {symbol:'APRMON', address:'0x0000000000000000000000000000000000000005', decimals:18},
      {symbol:'ETH', address:'0x0000000000000000000000000000000000000006', decimals:18},
      {symbol:'WETH', address:'0x0000000000000000000000000000000000000007', decimals:18},
      {symbol:'WSOLANA', address:'0x0000000000000000000000000000000000000008', decimals:18},
      {symbol:'BEAN', address:'0x0000000000000000000000000000000000000009', decimals:18},
    ];

    // Placeholder ABI for ERC20 token balanceOf and decimals and transfer
    const ERC20_ABI = [
      "function balanceOf(address) view returns (uint)",
      "function decimals() view returns (uint8)",
      "function approve(address spender, uint amount) returns (bool)",
      "function allowance(address owner, address spender) view returns (uint)",
      "function transfer(address to, uint amount) returns (bool)"
    ];

    // For demonstration, we won't implement full swap/liquidity contracts here.

    let provider = null;
    let signer = null;
    let userAddress = "";
    let chainId = null;

    // HTML references
    const connectButton = document.getElementById('connectWallet');
    const walletAddressSpan = document.getElementById('wallet-address');
    const tabButtons = document.querySelectorAll('nav button');
    const tabSections = document.querySelectorAll('main section.tab-content');
    const messageBox = document.getElementById('message');
    const balanceList = document.getElementById('balanceList');

    // Confirmation modal elements
    const confirmOverlay = document.getElementById('confirmOverlay');
    const confirmText = document.getElementById('confirmText');
    const confirmBtn = confirmOverlay.querySelector('button.confirmBtn');
    const cancelBtn = confirmOverlay.querySelector('button.cancelBtn');

    // Forms
    const swapForm = document.getElementById('swapForm');
    const liquidityForm = document.getElementById('liquidityForm');
    const stakeForm = document.getElementById('stakeForm');
    const unstakeForm = document.getElementById('unstakeForm');
    const deployForm = document.getElementById('deployForm');
    const nftForm = document.getElementById('nftForm');
    const crosschainForm = document.getElementById('crosschainForm');
    const crosschainGoBtn = document.getElementById('crosschain-go');

    // Helper utilities
    function showMessage(msg, isError=false, duration=5000) {
      messageBox.textContent = msg;
      messageBox.style.backgroundColor = isError ? '#bb0000' : '#006633';
      messageBox.style.display = 'block';
      setTimeout(() => {
        messageBox.style.display = 'none';
      }, duration);
    }

    async function connectWallet() {
      if (window.ethereum) {
        try {
          await window.ethereum.request({ method: 'eth_requestAccounts' });
          provider = new ethers.providers.Web3Provider(window.ethereum);
          signer = provider.getSigner();
          userAddress = await signer.getAddress();
          chainId = (await provider.getNetwork()).chainId;
          walletAddressSpan.textContent = userAddress;
          connectButton.textContent = "Disconnect Wallet";
          enableForms();
          await loadBalances();
          showMessage('Wallet connected: ' + userAddress);
          window.ethereum.on('accountsChanged', handleAccountsChanged);
          window.ethereum.on('chainChanged', handleChainChanged);
        } catch (err) {
          showMessage('Connection rejected or failed: ' + err.message, true);
        }
      } else {
        showMessage('No EVM wallet found. Please install MetaMask or compatible wallet.', true);
      }
    }

    function disconnectWallet() {
      provider = null;
      signer = null;
      userAddress = "";
      walletAddressSpan.textContent = "Not Connected";
      connectButton.textContent = "Connect Wallet";
      disableForms();
      clearBalances();
      showMessage('Wallet disconnected');
      window.location.reload(); // reload to reset state
    }

    function handleAccountsChanged(accounts) {
      if (accounts.length === 0) {
        disconnectWallet();
      } else {
        userAddress = accounts[0];
        walletAddressSpan.textContent = userAddress;
        loadBalances();
      }
    }

    async function handleChainChanged(_chainId) {
      chainId = parseInt(_chainId, 16);
      showMessage('Network changed to ' + chainId);
      await loadBalances();
    }

    // Initialize the page UI
    function initialize() {
      setupTokenSelects();
      disableForms();
      showTab('swap');

      connectButton.addEventListener('click', () => {
        if (provider) {
          disconnectWallet();
        } else {
          connectWallet();
        }
      });

      tabButtons.forEach(btn => {
        btn.addEventListener('click', e => {
          const tab = e.target.dataset.tab;
          showTab(tab);
        });
      });

      // Form handlers
      swapForm.addEventListener('submit', handleSwap);
      liquidityForm.addEventListener('submit', handleLiquidity);
      stakeForm.addEventListener('submit', handleStake);
      unstakeForm.addEventListener('submit', handleUnstake);
      deployForm.addEventListener('submit', handleDeploy);
      nftForm.addEventListener('submit', handleCreateNFT);
      crosschainGoBtn.addEventListener('click', handleCrosschain);

      // Confirmation modal
      confirmBtn.addEventListener('click', () => {
        if (confirmOverlay.confirmResolve) confirmOverlay.confirmResolve(true);
        hideConfirm();
      });
      cancelBtn.addEventListener('click', () => {
        if (confirmOverlay.confirmResolve) confirmOverlay.confirmResolve(false);
        hideConfirm();
      });
    }

    function setupTokenSelects() {
      const selects = [
        'swap-from', 'swap-to',
        'liquidity-token1', 'liquidity-token2',
        'stake-token',
        'unstake-token'
      ];
      selects.forEach(id => {
        const sel = document.getElementById(id);
        tokens.forEach(t => {
          const option = document.createElement('option');
          option.value = t.address;
          option.textContent = `${t.symbol}`;
          sel.appendChild(option);
        });
      });
    }

    function enableForms() {
      const buttons = document.querySelectorAll('button.actionBtn');
      buttons.forEach(btn => btn.disabled = false);
      // crosschain Go button enabled
      crosschainGoBtn.disabled = false;
    }
    function disableForms() {
      const buttons = document.querySelectorAll('button.actionBtn');
      buttons.forEach(btn => btn.disabled = true);
      crosschainGoBtn.disabled = true;
    }

    async function loadBalances() {
      clearBalances();
      if (!provider || !userAddress) return;
      balanceList.innerHTML = '';

      for (const token of tokens) {
        try {
          const tokenContract = new ethers.Contract(token.address, ERC20_ABI, provider);
          const rawBalance = await tokenContract.balanceOf(userAddress);
          const formatted = ethers.utils.formatUnits(rawBalance, token.decimals);
          const li = document.createElement('li');
          li.textContent = `${token.symbol}: ${parseFloat(formatted).toFixed(4)}`;
          balanceList.appendChild(li);
        } catch (error) {
          const li = document.createElement('li');
          li.textContent = `${token.symbol}: error`;
          balanceList.appendChild(li);
        }
      }
    }

    function clearBalances() {
      balanceList.innerHTML = '<li>Connect wallet to see balances</li>';
    }

    function showTab(tabName) {
      tabSections.forEach(sec => {
        if (sec.id === tabName) {
          sec.hidden = false;
        } else {
          sec.hidden = true;
        }
      });
      tabButtons.forEach(btn => {
        if (btn.dataset.tab === tabName) {
          btn.classList.add('active');
          btn.setAttribute('aria-selected', 'true');
        } else {
          btn.classList.remove('active');
          btn.setAttribute('aria-selected', 'false');
        }
      });
      // Clear messages and form inputs for best experience
      messageBox.style.display = 'none';
      clearAllFormInputs();
    }

    function clearAllFormInputs() {
      const forms = document.querySelectorAll('form');
      forms.forEach(form => form.reset());
    }

    async function handleSwap(e) {
      e.preventDefault();
      if (!signer) {
        showMessage('Please connect your wallet first.', true);
        return;
      }
      const fromAddress = swapForm['swap-from'].value;
      const toAddress = swapForm['swap-to'].value;
      const amountStr = swapForm['swap-amount'].value;
      if (fromAddress === toAddress) {
        showMessage('Select different tokens for swap.', true);
        return;
      }
      const amount = parseFloat(amountStr);
      if (amount <= 0 || isNaN(amount)) {
        showMessage('Enter a valid amount.', true);
        return;
      }
      // Confirmation modal
      const confirmed = await confirmDialog(`Confirm swap ${amount} units from ${getSymbol(fromAddress)} to ${getSymbol(toAddress)}?`);
      if (!confirmed) {
        showMessage('Swap cancelled.');
        return;
      }
      // Here you would implement real swap transaction logic on your contracts
      // We'll simulate delay and success
      showMessage('Processing swap transaction...');
      try {
        // Simulate async transaction
        await new Promise(r => setTimeout(r, 2000));
        showMessage(`Swap successful: ${amount} ${getSymbol(fromAddress)} â†’ ${getSymbol(toAddress)}`);
        await loadBalances();
      } catch (err) {
        showMessage('Swap failed: ' + err.message, true);
      }
    }

    async function handleLiquidity(e) {
      e.preventDefault();
      if (!signer) {
        showMessage('Please connect your wallet first.', true);
        return;
      }
      const token1Address = liquidityForm['liquidity-token1'].value;
      const token2Address = liquidityForm['liquidity-token2'].value;
      const amount1Str = liquidityForm['liquidity-amount1'].value;
      const amount2Str = liquidityForm['liquidity-amount2'].value;

      if (token1Address === token2Address) {
        showMessage('Select different tokens for liquidity.', true);
        return;
      }
      const amount1 = parseFloat(amount1Str);
      const amount2 = parseFloat(amount2Str);
      if(amount1 <= 0 || amount2 <= 0 || isNaN(amount1) || isNaN(amount2)) {
        showMessage('Enter valid amounts for both tokens.', true);
        return;
      }
      const confirmed = await confirmDialog(`Confirm add liquidity: ${amount1} ${getSymbol(token1Address)} + ${amount2} ${getSymbol(token2Address)}?`);
      if(!confirmed) {
        showMessage('Add liquidity cancelled.');
        return;
      }
      showMessage('Processing add liquidity transaction...');
      try {
        await new Promise(r => setTimeout(r, 2000));
        showMessage(`Liquidity added: ${amount1} ${getSymbol(token1Address)} + ${amount2} ${getSymbol(token2Address)}`);
        await loadBalances();
      } catch (err) {
        showMessage('Add liquidity failed: ' + err.message, true);
      }
    }

    async function handleStake(e) {
      e.preventDefault();
      if (!signer) {
        showMessage('Please connect your wallet first.', true);
        return;
      }
      const tokenAddress = stakeForm['stake-token'].value;
      const amountStr = stakeForm['stake-amount'].value;
      const amount = parseFloat(amountStr);
      if (amount <= 0 || isNaN(amount)) {
        showMessage('Enter a valid amount.', true);
        return;
      }
      const confirmed = await confirmDialog(`Confirm stake ${amount} ${getSymbol(tokenAddress)}?`);
      if (!confirmed) {
        showMessage('Stake cancelled.');
        return;
      }
      showMessage('Processing stake transaction...');
      try {
        await new Promise(r => setTimeout(r, 2000));
        showMessage(`Stake successful: ${amount} ${getSymbol(tokenAddress)}`);
        await loadBalances();
      } catch (err) {
        showMessage('Stake failed: ' + err.message, true);
      }
    }

    async function handleUnstake(e) {
      e.preventDefault();
      if (!signer) {
        showMessage('Please connect your wallet first.', true);
        return;
      }
      const tokenAddress = unstakeForm['unstake-token'].value;
      const amountStr = unstakeForm['unstake-amount'].value;
      const amount = parseFloat(amountStr);
      if (amount <= 0 || isNaN(amount)) {
        showMessage('Enter a valid amount.', true);
        return;
      }
      const confirmed = await confirmDialog(`Confirm unstake ${amount} ${getSymbol(tokenAddress)}?`);
      if (!confirmed) {
        showMessage('Unstake cancelled.');
        return;
      }
      showMessage('Processing unstake transaction...');
      try {
        await new Promise(r => setTimeout(r, 2000));
        showMessage(`Unstake successful: ${amount} ${getSymbol(tokenAddress)}`);
        await loadBalances();
      } catch (err) {
        showMessage('Unstake failed: ' + err.message, true);
      }
    }

    async function handleDeploy(e) {
      e.preventDefault();
      if (!signer) {
        showMessage('Please connect your wallet first.', true);
        return;
      }
      const name = deployForm['deploy-name'].value.trim();
      const symbol = deployForm['deploy-symbol'].value.trim();
      const supplyStr = deployForm['deploy-supply'].value;
      if (!name || !symbol || !supplyStr) {
        showMessage('Fill all deploy fields.', true);
        return;
      }
      const supply = BigInt(supplyStr);
      const confirmed = await confirmDialog(`Confirm deploy ERC20 token "${name}" (${symbol}) with supply ${supply}?`);
      if (!confirmed) {
        showMessage('Deploy cancelled.');
        return;
      }
      showMessage('Deploying smart contract...');
      try {
        // Simulate deploy delay
        await new Promise(r => setTimeout(r, 3000));
        showMessage(`Token deployed: ${name} (${symbol}) with supply ${supplyStr}`);
        await loadBalances();
      } catch (err) {
        showMessage('Deploy failed: ' + err.message, true);
      }
    }

    async function handleCreateNFT(e) {
      e.preventDefault();
      if (!signer) {
        showMessage('Please connect your wallet first.', true);
        return;
      }
      const name = nftForm['nft-name'].value.trim();
      const desc = nftForm['nft-description'].value.trim();
      const uri = nftForm['nft-uri'].value.trim();
      if (!name || !desc || !uri) {
        showMessage('Fill all NFT fields.', true);
        return;
      }
      const confirmed = await confirmDialog(`Confirm create NFT "${name}" with metadata URI:\n${uri}`);
      if (!confirmed) {
        showMessage('Create NFT cancelled.');
        return;
      }
      showMessage('Creating NFT...');
      try {
        await new Promise(r => setTimeout(r, 3000));
        showMessage(`NFT created: ${name}`);
      } catch (err) {
        showMessage('Create NFT failed: ' + err.message, true);
      }
    }

    async function handleCrosschain() {
      if (!signer) {
        showMessage('Please connect your wallet first.', true);
        return;
      }
      const network = crosschainForm['crosschain-network'].value;
      const action = crosschainForm['crosschain-action'].value;

      showMessage(`Preparing crosschain transaction on ${network} with action ${action}...`);

      // Attempt network switch if supported
      try {
        await switchNetwork(network);
        showMessage(`Switched to ${network} network. Ready to execute ${action}.`);
      } catch (err) {
        showMessage(`Network switch to ${network} failed or not supported: ${err.message}`, true);
      }
      // In a real app here you would trigger the corresponding action on the selected network
    }

    async function switchNetwork(networkKey) {
      // Basic network params for demonstration
      const networks = {
        monad_testnet: { chainId: '0x1029', chainName: 'Monad Testnet', rpcUrls: ['https://rpc.monadtestnet.example'] },
        rinkeby: { chainId: '0x4', chainName: 'Rinkeby Testnet', rpcUrls: ['https://rinkeby.infura.io/v3/'] },
        bsc_testnet: { chainId: '0x61', chainName: 'BSC Testnet', rpcUrls: ['https://data-seed-prebsc-1-s1.binance.org:8545/'] },
        polygon_testnet: { chainId: '0x13881', chainName: 'Polygon Mumbai', rpcUrls: ['https://rpc-mumbai.maticvigil.com/'] },
      };

      if (!window.ethereum) throw new Error('No Ethereum wallet found.');

      const net = networks[networkKey];
      if (!net) throw new Error('Network not configured.');

      try {
        await window.ethereum.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: net.chainId }],
        });
        chainId = parseInt(net.chainId, 16);
      } catch (switchError) {
        // If the network is not added to MetaMask then add it
        if (switchError.code === 4902) {
          try {
            await window.ethereum.request({
              method: 'wallet_addEthereumChain',
              params: [{
                chainId: net.chainId,
                chainName: net.chainName,
                rpcUrls: net.rpcUrls,
                nativeCurrency: { name: 'TOKEN', symbol: 'TKN', decimals: 18 }
              }],
            });
            chainId = parseInt(net.chainId, 16);
          } catch (addError) {
            throw addError;
          }
        } else {
          throw switchError;
        }
      }
    }

    function getSymbol(tokenAddress) {
      const token = tokens.find(t => t.address.toLowerCase() === tokenAddress.toLowerCase());
      return token ? token.symbol : tokenAddress;
    }

    async function confirmDialog(message) {
      confirmText.textContent = message;
      confirmOverlay.style.display = 'flex';
      return new Promise(resolve => {
        confirmOverlay.confirmResolve = resolve;
      });
    }

    function hideConfirm() {
      confirmOverlay.style.display = 'none';
      confirmOverlay.confirmResolve = null;
    }

    initialize();
  })();
</script>
</body>
</html>

